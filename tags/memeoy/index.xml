<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memeoy on Yu's Space</title><link>https://code-agree.github.io/tags/memeoy/</link><description>Recent content in Memeoy on Yu's Space</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 22 Oct 2024 01:23:46 +0800</lastBuildDate><atom:link href="https://code-agree.github.io/tags/memeoy/index.xml" rel="self" type="application/rss+xml"/><item><title>内存映射（mmap）与零拷贝技术：深入理解和实践</title><link>https://code-agree.github.io/blog/zero_copy/</link><pubDate>Tue, 22 Oct 2024 01:23:46 +0800</pubDate><guid>https://code-agree.github.io/blog/zero_copy/</guid><description>&lt;h2 id="1-概述" class="relative group">1. 概述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e6%a6%82%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>内存映射（mmap）是一种将文件或设备映射到内存的方法，而零拷贝是一种减少或避免数据在内核空间和用户空间之间不必要复制的技术。这两个概念密切相关，但又有所不同。&lt;/p>
&lt;h2 id="2-mmap-是零拷贝吗" class="relative group">2. mmap 是零拷贝吗？ &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-mmap-%e6%98%af%e9%9b%b6%e6%8b%b7%e8%b4%9d%e5%90%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>答案是：&lt;strong>mmap 本身不是零拷贝技术，但它可以实现零拷贝的效果&lt;/strong>。&lt;/p>
&lt;h3 id="21-mmap-的工作原理" class="relative group">2.1 mmap 的工作原理 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-mmap-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ol>
&lt;li>当调用 mmap 时，操作系统会在虚拟内存中创建一个新的内存区域。&lt;/li>
&lt;li>这个内存区域会映射到文件系统缓存（page cache）中的物理页面。&lt;/li>
&lt;li>当程序访问这个内存区域时，如果相应的页面不在内存中，会触发缺页中断，操作系统会从磁盘加载数据到内存。&lt;/li>
&lt;/ol>
&lt;h3 id="22-为什么-mmap-可以实现零拷贝" class="relative group">2.2 为什么 mmap 可以实现零拷贝 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#22-%e4%b8%ba%e4%bb%80%e4%b9%88-mmap-%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e9%9b%b6%e6%8b%b7%e8%b4%9d" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>一旦映射建立，用户进程可以直接读写这个内存区域，而无需在用户空间和内核空间之间进行数据复制。&lt;/li>
&lt;li>对于读操作，数据从磁盘读入 page cache 后，可以直接被用户进程访问，无需额外复制。&lt;/li>
&lt;li>对于写操作，修改直接发生在 page cache 上，操作系统会在适当的时候将修改同步到磁盘。&lt;/li>
&lt;/ul>
&lt;h2 id="3-mmap-与传统-io-的比较" class="relative group">3. mmap 与传统 I/O 的比较 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#3-mmap-%e4%b8%8e%e4%bc%a0%e7%bb%9f-io-%e7%9a%84%e6%af%94%e8%be%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="31-传统-read-系统调用" class="relative group">3.1 传统 read 系统调用 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#31-%e4%bc%a0%e7%bb%9f-read-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">char&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4096&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ssize_t&lt;/span> &lt;span class="n">bytes_read&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个过程涉及两次数据拷贝：&lt;/p></description></item></channel></rss>