<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能优化 on Yu's Space</title><link>https://example.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><description>Recent content in 性能优化 on Yu's Space</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 13 Oct 2024 03:18:35 +0800</lastBuildDate><atom:link href="https://example.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.xml" rel="self" type="application/rss+xml"/><item><title>高频交易系统中的位域压缩技术</title><link>https://example.org/blog/bit_field_compression/</link><pubDate>Sun, 13 Oct 2024 03:18:35 +0800</pubDate><guid>https://example.org/blog/bit_field_compression/</guid><description>&lt;h2 id="1-基础概念" class="relative group">1. 基础概念 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="11-二进制表示" class="relative group">1.1 二进制表示 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%a1%a8%e7%a4%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>计算机使用二进制（0和1）存储和处理数据&lt;/li>
&lt;li>1 byte = 8 bits&lt;/li>
&lt;li>32位整数可以表示从 0 到 2^32 - 1 的数值&lt;/li>
&lt;/ul>
&lt;h3 id="12-位操作基础" class="relative group">1.2 位操作基础 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e4%bd%8d%e6%93%8d%e4%bd%9c%e5%9f%ba%e7%a1%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>与操作 (&amp;amp;): 两位都为1时结果为1，否则为0&lt;/li>
&lt;li>或操作 (|): 至少一位为1时结果为1，否则为0&lt;/li>
&lt;li>异或操作 (^): 两位不同时结果为1，相同时为0&lt;/li>
&lt;li>非操作 (~): 将每一位取反&lt;/li>
&lt;li>左移 (&amp;laquo;): 将所有位向左移动，右侧补0&lt;/li>
&lt;li>右移 (&amp;raquo;): 将所有位向右移动，左侧补0或符号位&lt;/li>
&lt;/ul>
&lt;p>示例：&lt;/p></description></item><item><title>高频交易系统中的重连机制最佳实践</title><link>https://example.org/blog/atom/</link><pubDate>Fri, 27 Sep 2024 01:35:21 +0800</pubDate><guid>https://example.org/blog/atom/</guid><description>&lt;h1 id="高频交易系统中的重连机制最佳实践" class="relative group">高频交易系统中的重连机制最佳实践 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e9%87%8d%e8%bf%9e%e6%9c%ba%e5%88%b6%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="背景" class="relative group">背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在高频交易系统中，网络连接的稳定性至关重要。然而，由于网络波动或其他原因，连接可能会中断。为了确保系统的连续性和可靠性，需要实现一个高效的重连机制。然而，频繁的重连检查和处理可能导致重复重连，影响系统性能。&lt;/p>
&lt;h2 id="问题描述" class="relative group">问题描述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在现有实现中，主循环频繁检查 &lt;code>m_client-&amp;gt;needsReconnection()&lt;/code>，如果需要重连，则调用 &lt;code>handleReconnect()&lt;/code>。然而，由于主循环速度很快，可能在 &lt;code>resetReconnectionFlag()&lt;/code> 生效前再次检查 &lt;code>needsReconnection()&lt;/code>，导致重复调用 &lt;code>handleReconnect()&lt;/code>。&lt;/p>
&lt;h2 id="解决方案" class="relative group">解决方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>通过使用原子操作和双重检查机制，确保重连过程的原子性和一致性，避免重复重连。&lt;/p>
&lt;h3 id="1-定义连接状态管理" class="relative group">1. 定义连接状态管理 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%ae%9a%e4%b9%89%e8%bf%9e%e6%8e%a5%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>使用原子变量来管理连接状态，确保线程安全。&lt;/p></description></item><item><title>高频交易系统优化：从数据读取到系统平衡的思考过程</title><link>https://example.org/blog/datareader_design/</link><pubDate>Wed, 25 Sep 2024 01:04:59 +0800</pubDate><guid>https://example.org/blog/datareader_design/</guid><description>&lt;h2 id="1-初始问题数据读取效率" class="relative group">1. 初始问题：数据读取效率 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%88%9d%e5%a7%8b%e9%97%ae%e9%a2%98%e6%95%b0%e6%8d%ae%e8%af%bb%e5%8f%96%e6%95%88%e7%8e%87" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>最初，我们关注的是市场数据读取器本身的效率问题。&lt;/p>
&lt;h3 id="11-轮询方式初始状态" class="relative group">1.1 轮询方式（初始状态） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e8%bd%ae%e8%af%a2%e6%96%b9%e5%bc%8f%e5%88%9d%e5%a7%8b%e7%8a%b6%e6%80%81" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">MarketDataReader&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">readingLoop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">running&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">symbol&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">symbols_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">processSymbol&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">symbol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">this_thread&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">sleep_for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">milliseconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题：持续轮询即使在没有新数据时也会消耗资源。&lt;/p>
&lt;h3 id="12-条件控制方式" class="relative group">1.2 条件控制方式 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e6%9d%a1%e4%bb%b6%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">MarketDataReader&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">readingLoop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">running&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">conditionMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dataCondition&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">running&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">symbols_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">symbol&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">symbols_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">processSymbol&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">symbol&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改进：减少了不必要的CPU使用，但可能会在高频数据更新时引入延迟。&lt;/p>
&lt;p>思考转变：这个阶段，我们主要关注如何提高单个组件（数据读取器）的效率。&lt;/p>
&lt;h2 id="2-扩展考虑数据读取对其他系统组件的影响" class="relative group">2. 扩展考虑：数据读取对其他系统组件的影响 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-%e6%89%a9%e5%b1%95%e8%80%83%e8%99%91%e6%95%b0%e6%8d%ae%e8%af%bb%e5%8f%96%e5%af%b9%e5%85%b6%e4%bb%96%e7%b3%bb%e7%bb%9f%e7%bb%84%e4%bb%b6%e7%9a%84%e5%bd%b1%e5%93%8d" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>随着对系统的深入思考，我们开始考虑数据读取器的行为如何影响整个系统，特别是订单流的执行效率。&lt;/p></description></item></channel></rss>