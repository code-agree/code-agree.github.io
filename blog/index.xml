<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Yu's Space</title><link>https://code-agree.github.io/blog/</link><description>Recent content in Blog on Yu's Space</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 06 Dec 2024 17:45:16 +0800</lastBuildDate><atom:link href="https://code-agree.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>高性能订单执行系统设计方案</title><link>https://code-agree.github.io/blog/batch_order/</link><pubDate>Fri, 06 Dec 2024 17:45:16 +0800</pubDate><guid>https://code-agree.github.io/blog/batch_order/</guid><description>&lt;h1 id="高性能订单执行系统设计方案" class="relative group">高性能订单执行系统设计方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e6%80%a7%e8%83%bd%e8%ae%a2%e5%8d%95%e6%89%a7%e8%a1%8c%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e6%96%b9%e6%a1%88" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="1-背景问题" class="relative group">1. 背景问题 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e8%83%8c%e6%99%af%e9%97%ae%e9%a2%98" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="11-性能挑战" class="relative group">1.1 性能挑战 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e6%80%a7%e8%83%bd%e6%8c%91%e6%88%98" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>高吞吐量订单处理需求&lt;/li>
&lt;li>每个订单都需要 HTTP 请求&lt;/li>
&lt;li>JWT Token 生成开销大&lt;/li>
&lt;li>网络延迟敏感&lt;/li>
&lt;/ul>
&lt;h3 id="12-主要痛点" class="relative group">1.2 主要痛点 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e4%b8%bb%e8%a6%81%e7%97%9b%e7%82%b9" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>单个订单发送造成网络请求过多&lt;/li>
&lt;li>JWT Token 频繁生成浪费资源&lt;/li>
&lt;li>大量订单并发可能导致系统瓶颈&lt;/li>
&lt;/ul>
&lt;h2 id="2-解决方案" class="relative group">2. 解决方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="21-jwt-token-缓存机制" class="relative group">2.1 JWT Token 缓存机制 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-jwt-token-%e7%bc%93%e5%ad%98%e6%9c%ba%e5%88%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">RestClient&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="k">constexpr&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="n">JWT_REFRESH_INTERVAL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">110&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 预留刷新窗口
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">getOrCreateJWT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">uri&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">auto&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">chrono&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">steady_clock&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">token&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">expiryTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">token&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">token&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">generateJWT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uri&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">expiryTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">JWT_REFRESH_INTERVAL&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">cache&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">token&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p></description></item><item><title>高性能网络编程：io_uring 与内存优化技术详解</title><link>https://code-agree.github.io/blog/io_uring/</link><pubDate>Fri, 06 Dec 2024 06:04:25 +0800</pubDate><guid>https://code-agree.github.io/blog/io_uring/</guid><description>&lt;h1 id="高性能网络编程io_uring-与内存优化技术详解" class="relative group">高性能网络编程：io_uring 与内存优化技术详解 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8bio_uring-%e4%b8%8e%e5%86%85%e5%ad%98%e4%bc%98%e5%8c%96%e6%8a%80%e6%9c%af%e8%af%a6%e8%a7%a3" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="0-内存管理优化" class="relative group">0. 内存管理优化 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#0-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%bc%98%e5%8c%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="01-大页内存-huge-pages" class="relative group">0.1 大页内存 (Huge Pages) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#01-%e5%a4%a7%e9%a1%b5%e5%86%85%e5%ad%98-huge-pages" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>大页内存是一种内存管理优化技术，主要优势：&lt;/p></description></item><item><title>高频交易场景下的多WS连接低延时方案设计</title><link>https://code-agree.github.io/blog/multiquotedata/</link><pubDate>Tue, 03 Dec 2024 01:01:26 +0800</pubDate><guid>https://code-agree.github.io/blog/multiquotedata/</guid><description>&lt;h2 id="1-业务背景与挑战" class="relative group">1. 业务背景与挑战 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e4%b8%9a%e5%8a%a1%e8%83%8c%e6%99%af%e4%b8%8e%e6%8c%91%e6%88%98" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在高频交易系统中，需要同时维护多个WebSocket连接以订阅不同交易所的行情数据。主要挑战包括：&lt;/p></description></item><item><title>付鹏HSBC</title><link>https://code-agree.github.io/blog/fupeng/</link><pubDate>Sun, 01 Dec 2024 21:06:34 +0800</pubDate><guid>https://code-agree.github.io/blog/fupeng/</guid><description>&lt;p>HSBC 速记
汇丰私人财富规划&lt;/p></description></item><item><title>OrderBook 本地维护方案设计</title><link>https://code-agree.github.io/blog/orderbook/</link><pubDate>Wed, 27 Nov 2024 02:35:19 +0800</pubDate><guid>https://code-agree.github.io/blog/orderbook/</guid><description>&lt;h1 id="orderbook-本地维护方案设计" class="relative group">OrderBook 本地维护方案设计 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#orderbook-%e6%9c%ac%e5%9c%b0%e7%bb%b4%e6%8a%a4%e6%96%b9%e6%a1%88%e8%ae%be%e8%ae%a1" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="一业务背景" class="relative group">一、业务背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%b8%80%e4%b8%9a%e5%8a%a1%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>OrderBook（订单簿）是反映市场深度和流动性的核心数据结构，其维护质量直接影响：&lt;/p></description></item><item><title>内存映射（mmap）与零拷贝技术：深入理解和实践</title><link>https://code-agree.github.io/blog/zero_copy/</link><pubDate>Tue, 22 Oct 2024 01:23:46 +0800</pubDate><guid>https://code-agree.github.io/blog/zero_copy/</guid><description>&lt;h2 id="1-概述" class="relative group">1. 概述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e6%a6%82%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>内存映射（mmap）是一种将文件或设备映射到内存的方法，而零拷贝是一种减少或避免数据在内核空间和用户空间之间不必要复制的技术。这两个概念密切相关，但又有所不同。&lt;/p></description></item><item><title>GitHub私有仓库协同开发指南</title><link>https://code-agree.github.io/blog/project_manage/</link><pubDate>Wed, 16 Oct 2024 02:04:51 +0800</pubDate><guid>https://code-agree.github.io/blog/project_manage/</guid><description>&lt;h2 id="目录" class="relative group">目录 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%9b%ae%e5%bd%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>&lt;a href="#%e7%ae%80%e4%bb%8b">简介&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e4%bb%93%e5%ba%93%e7%bb%93%e6%9e%84%e5%92%8c%e5%88%86%e6%94%af%e7%ad%96%e7%95%a5">仓库结构和分支策略&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e5%8d%8f%e4%bd%9c%e8%80%85%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86">协作者权限管理&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e4%bf%9d%e6%8a%a4%e4%b8%bb%e5%88%86%e6%94%af">保护主分支&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pull-request-%e5%92%8c%e4%bb%a3%e7%a0%81%e5%ae%a1%e6%9f%a5%e6%b5%81%e7%a8%8b">Pull Request 和代码审查流程&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e4%b8%8e%e9%83%a8%e7%bd%b2-cicd">持续集成与部署 (CI/CD)&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%96%87%e6%a1%a3%e5%92%8c%e6%b2%9f%e9%80%9a">文档和沟通&lt;/a>&lt;/li>
&lt;li>&lt;a href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e5%92%8c%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">最佳实践和注意事项&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="简介" class="relative group">简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在没有高级 GitHub 功能的私有仓库中进行协同开发可能具有挑战性，但通过正确的实践和工具，我们可以建立一个高效、安全的开发环境。本指南总结了我们讨论的主要策略和技术。&lt;/p></description></item><item><title>Fork机制详解：从基础到高级应用</title><link>https://code-agree.github.io/blog/fork/</link><pubDate>Tue, 15 Oct 2024 02:45:13 +0800</pubDate><guid>https://code-agree.github.io/blog/fork/</guid><description>&lt;h2 id="1-引言" class="relative group">1. 引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Fork是Unix/Linux系统中最基本也是最强大的系统调用之一。它允许一个进程创建一个新的进程,这个新进程是原进程的一个几乎完全相同的副本。本次技术分享将深入探讨fork机制,从基本概念到高级应用。&lt;/p></description></item><item><title>高频交易系统中的位域压缩技术</title><link>https://code-agree.github.io/blog/bit_field_compression/</link><pubDate>Sun, 13 Oct 2024 03:18:35 +0800</pubDate><guid>https://code-agree.github.io/blog/bit_field_compression/</guid><description>&lt;h2 id="1-基础概念" class="relative group">1. 基础概念 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="11-二进制表示" class="relative group">1.1 二进制表示 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%a1%a8%e7%a4%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>计算机使用二进制（0和1）存储和处理数据&lt;/li>
&lt;li>1 byte = 8 bits&lt;/li>
&lt;li>32位整数可以表示从 0 到 2^32 - 1 的数值&lt;/li>
&lt;/ul>
&lt;h3 id="12-位操作基础" class="relative group">1.2 位操作基础 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e4%bd%8d%e6%93%8d%e4%bd%9c%e5%9f%ba%e7%a1%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>与操作 (&amp;amp;): 两位都为1时结果为1，否则为0&lt;/li>
&lt;li>或操作 (|): 至少一位为1时结果为1，否则为0&lt;/li>
&lt;li>异或操作 (^): 两位不同时结果为1，相同时为0&lt;/li>
&lt;li>非操作 (~): 将每一位取反&lt;/li>
&lt;li>左移 (&amp;laquo;): 将所有位向左移动，右侧补0&lt;/li>
&lt;li>右移 (&amp;raquo;): 将所有位向右移动，左侧补0或符号位&lt;/li>
&lt;/ul>
&lt;p>示例：&lt;/p></description></item><item><title>高频交易系统中的市场数据存储优化</title><link>https://code-agree.github.io/blog/read/</link><pubDate>Sun, 29 Sep 2024 01:36:04 +0800</pubDate><guid>https://code-agree.github.io/blog/read/</guid><description>&lt;h2 id="1-背景介绍" class="relative group">1. 背景介绍 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在高频交易系统中，市场数据的快速读取和处理是关键性能指标之一。我们的系统使用共享内存来存储和访问实时市场数据，其中 &lt;code>MarketDataStore&lt;/code> 类负责管理这些数据。本文将讨论如何优化 &lt;code>MarketDataStore&lt;/code> 中的 &lt;code>readLatestData&lt;/code> 函数，以提高数据读取的效率。&lt;/p></description></item><item><title>高频交易系统中的重连机制最佳实践</title><link>https://code-agree.github.io/blog/atom/</link><pubDate>Fri, 27 Sep 2024 01:35:21 +0800</pubDate><guid>https://code-agree.github.io/blog/atom/</guid><description>&lt;h1 id="高频交易系统中的重连机制最佳实践" class="relative group">高频交易系统中的重连机制最佳实践 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e9%87%8d%e8%bf%9e%e6%9c%ba%e5%88%b6%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="背景" class="relative group">背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在高频交易系统中，网络连接的稳定性至关重要。然而，由于网络波动或其他原因，连接可能会中断。为了确保系统的连续性和可靠性，需要实现一个高效的重连机制。然而，频繁的重连检查和处理可能导致重复重连，影响系统性能。&lt;/p></description></item><item><title>高频交易系统优化：从数据读取到系统平衡的思考过程</title><link>https://code-agree.github.io/blog/datareader_design/</link><pubDate>Wed, 25 Sep 2024 01:04:59 +0800</pubDate><guid>https://code-agree.github.io/blog/datareader_design/</guid><description>&lt;h2 id="1-初始问题数据读取效率" class="relative group">1. 初始问题：数据读取效率 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%88%9d%e5%a7%8b%e9%97%ae%e9%a2%98%e6%95%b0%e6%8d%ae%e8%af%bb%e5%8f%96%e6%95%88%e7%8e%87" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>最初，我们关注的是市场数据读取器本身的效率问题。&lt;/p></description></item><item><title>实现高性能低延迟的交易系统设计</title><link>https://code-agree.github.io/blog/high_performance/</link><pubDate>Fri, 20 Sep 2024 22:32:08 +0800</pubDate><guid>https://code-agree.github.io/blog/high_performance/</guid><description>&lt;h1 id="高性能低延迟交易系统设计技术分享-update" class="relative group">高性能低延迟交易系统设计：技术分享 update &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e6%80%a7%e8%83%bd%e4%bd%8e%e5%bb%b6%e8%bf%9f%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e6%8a%80%e6%9c%af%e5%88%86%e4%ba%ab-update" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>在高频交易和实时金融系统中，性能和延迟是关键因素。本文将分享一些设计和实现高性能低延迟交易系统的关键技术和策略。&lt;/p></description></item><item><title>高频交易系统中的高层锁定：必要性与实现</title><link>https://code-agree.github.io/blog/mutex/</link><pubDate>Wed, 18 Sep 2024 17:29:59 +0800</pubDate><guid>https://code-agree.github.io/blog/mutex/</guid><description>&lt;p>在高频交易系统的开发中，我们经常面临着性能和正确性之间的权衡。最近，我们在优化订单处理流程时，发现了一个有趣的问题：是否需要在高层组件中实现锁定？本文将深入探讨这个问题，分析其必要性，并展示优化前后的实现。&lt;/p></description></item><item><title>高频交易系统优化：从WebSocket到市场数据处理的全面解析</title><link>https://code-agree.github.io/blog/queue_usage2/</link><pubDate>Sun, 15 Sep 2024 04:03:51 +0800</pubDate><guid>https://code-agree.github.io/blog/queue_usage2/</guid><description>&lt;h1 id="高频交易系统优化从websocket到市场数据处理的全面解析" class="relative group">高频交易系统优化：从WebSocket到市场数据处理的全面解析 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e4%bc%98%e5%8c%96%e4%bb%8ewebsocket%e5%88%b0%e5%b8%82%e5%9c%ba%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e7%9a%84%e5%85%a8%e9%9d%a2%e8%a7%a3%e6%9e%90" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>在当今竞争激烈的金融市场中,高频交易(HFT)系统的性能直接关系到交易策略的成功与否。本文将深入探讨高频交易系统中两个关键环节的优化：WebSocket消息接收机制和市场数据处理。我们将分析当前最佳实践,探讨潜在的优化方向,并提供具体的代码示例。&lt;/p></description></item><item><title>高频交易系统中市场数据处理：队列的利弊分析</title><link>https://code-agree.github.io/blog/queue_usage/</link><pubDate>Sun, 15 Sep 2024 03:57:13 +0800</pubDate><guid>https://code-agree.github.io/blog/queue_usage/</guid><description>&lt;h1 id="高频交易系统中市场数据处理队列的利弊分析" class="relative group">高频交易系统中市场数据处理：队列的利弊分析 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e4%b8%ad%e5%b8%82%e5%9c%ba%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e9%98%9f%e5%88%97%e7%9a%84%e5%88%a9%e5%bc%8a%e5%88%86%e6%9e%90" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>在高频交易（HFT）系统中，处理市场数据的方式直接影响着系统的性能和延迟。使用队列是一种常见的数据处理方法，但在追求极低延迟的HFT系统中，这种选择是否合适需要仔细考虑。本文将分析使用队列的利弊，并探讨可能的替代方案。&lt;/p></description></item><item><title>Segmentation Fault Caused by std::string in Memory-Mapped File</title><link>https://code-agree.github.io/blog/string_mmap/</link><pubDate>Thu, 12 Sep 2024 15:23:23 +0800</pubDate><guid>https://code-agree.github.io/blog/string_mmap/</guid><description>&lt;h1 id="故障复盘报告内存映射文件中的-stdstring-导致的段错误" class="relative group">故障复盘报告：内存映射文件中的 std::string 导致的段错误 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%85%e9%9a%9c%e5%a4%8d%e7%9b%98%e6%8a%a5%e5%91%8a%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84-stdstring-%e5%af%bc%e8%87%b4%e7%9a%84%e6%ae%b5%e9%94%99%e8%af%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="1-问题描述" class="relative group">1. 问题描述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在使用内存映射文件存储订单数据的过程中，程序在重启后出现段错误。具体表现为在尝试访问存储在内存映射文件中的 &lt;code>Order&lt;/code> 结构体的 &lt;code>id&lt;/code> 字段时，程序崩溃。&lt;/p></description></item><item><title>Analysis of Configuration Management in High-Frequency Trading System</title><link>https://code-agree.github.io/blog/config_managemeng_in_hft_system/</link><pubDate>Fri, 06 Sep 2024 01:47:52 +0800</pubDate><guid>https://code-agree.github.io/blog/config_managemeng_in_hft_system/</guid><description>&lt;h1 id="高频交易系统配置管理方案分析" class="relative group">高频交易系统配置管理方案分析 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e9%85%8d%e7%bd%ae%e7%ae%a1%e7%90%86%e6%96%b9%e6%a1%88%e5%88%86%e6%9e%90" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;h2 id="当前方案概述" class="relative group">当前方案概述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%bd%93%e5%89%8d%e6%96%b9%e6%a1%88%e6%a6%82%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;pre tabindex="0">&lt;code class="language-Mermaid" data-lang="Mermaid">
graph TB
 CommonLib[&amp;#34;Common Library (MMAP)&amp;#34;]
 Exchange[&amp;#34;Exchange&amp;#34;]

 subgraph StrategyAndTrading[&amp;#34;StrategyAndTrading Component&amp;#34;]
 MDR[&amp;#34;MarketDataReader&amp;#34;]
 MDN[&amp;#34;MarketDataNormalizer&amp;#34;]
 SM[&amp;#34;StrategyManager&amp;#34;]
 subgraph Strategies[&amp;#34;Strategies&amp;#34;]
 S1[&amp;#34;Strategy 1&amp;#34;]
 S2[&amp;#34;Strategy 2&amp;#34;]
 SN[&amp;#34;Strategy N&amp;#34;]
 end
 OG[&amp;#34;OrderGenerator&amp;#34;]
 OV[&amp;#34;OrderValidator&amp;#34;]
 RP[&amp;#34;RiskProfiler&amp;#34;]
 RE[&amp;#34;RiskEvaluator&amp;#34;]
 OM[&amp;#34;OrderManager&amp;#34;]
 OE[&amp;#34;OrderExecutor&amp;#34;]
 OMO[&amp;#34;OrderMonitor&amp;#34;]
 PM[&amp;#34;PositionManager&amp;#34;]
 end

 CommonLib --&amp;gt;|1. Read MMAP| MDR
 MDR --&amp;gt;|2. Raw Market Data| MDN
 MDN --&amp;gt;|3. Normalized Data| SM
 SM --&amp;gt;|4. Distribute Data| Strategies
 Strategies --&amp;gt;|5. Generate Signals| OG
 OG --&amp;gt;|6. Create Orders| OV
 OV --&amp;gt;|7. Validated Orders| RP
 RP --&amp;gt;|8. Risk Profile| RE
 RE --&amp;gt;|9. Risk Evaluated Orders| OM
 OM --&amp;gt;|10. Managed Orders| OE
 OE &amp;lt;--&amp;gt;|11. Execute Orders| Exchange
 Exchange --&amp;gt;|12. Execution Results| OMO
 OMO --&amp;gt;|13. Order Updates| OM
 OM --&amp;gt;|14. Position Updates| PM
 PM -.-&amp;gt;|15. Position Feedback| SM

 classDef external fill:#f9f,stroke:#333,stroke-width:2px;
 classDef component fill:#bbf,stroke:#333,stroke-width:1px;
 classDef strategy fill:#bfb,stroke:#333,stroke-width:1px;
 class CommonLib,Exchange external;
 class MDR,MDN,SM,OG,OV,RP,RE,OM,OE,OMO,PM component;
 class S1,S2,SN strategy;
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>Quote进程使用common静态库组件加载配置信息。&lt;/li>
&lt;li>配置信息加载到Quote进程的本地缓存中。&lt;/li>
&lt;li>使用观察者模式订阅common组件中config的变更。&lt;/li>
&lt;li>当配置变更时，Quote进程更新本地缓存、重新连接和重新订阅。&lt;/li>
&lt;/ol>
&lt;h2 id="优点分析" class="relative group">优点分析 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bc%98%e7%82%b9%e5%88%86%e6%9e%90" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>模块化设计&lt;/strong>：&lt;/p></description></item><item><title>How to publish new blog</title><link>https://code-agree.github.io/blog/how_to_publish_new_blog/</link><pubDate>Mon, 02 Sep 2024 12:36:27 +0800</pubDate><guid>https://code-agree.github.io/blog/how_to_publish_new_blog/</guid><description>&lt;h3 id="workflow" class="relative group">workflow &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#workflow" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>目前已经实现GitHub Action，自动编译静态文件, Push到GitHub Page。&lt;/p></description></item><item><title>Lock Free Queue Application</title><link>https://code-agree.github.io/blog/lockfree/</link><pubDate>Mon, 02 Sep 2024 02:10:33 +0800</pubDate><guid>https://code-agree.github.io/blog/lockfree/</guid><description>&lt;h3 id="标题解决高频交易系统中的死锁从传统-eventbus-到无锁队列的优化之旅" class="relative group">标题：解决高频交易系统中的死锁：从传统 EventBus 到无锁队列的优化之旅 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a0%87%e9%a2%98%e8%a7%a3%e5%86%b3%e9%ab%98%e9%a2%91%e4%ba%a4%e6%98%93%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e6%ad%bb%e9%94%81%e4%bb%8e%e4%bc%a0%e7%bb%9f-eventbus-%e5%88%b0%e6%97%a0%e9%94%81%e9%98%9f%e5%88%97%e7%9a%84%e4%bc%98%e5%8c%96%e4%b9%8b%e6%97%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>引言
在高频交易系统中，每一毫秒都至关重要。最近在系统中遇到了一个令人头疼的死锁问题，这不仅影响了系统的性能，还危及了其稳定性。本文将详细讲述如何发现、分析并最终解决这个问题，以及从中学到的宝贵经验。&lt;/p></description></item><item><title>First Post</title><link>https://code-agree.github.io/blog/two/</link><pubDate>Sun, 04 Aug 2024 00:13:28 +0800</pubDate><guid>https://code-agree.github.io/blog/two/</guid><description>&lt;h1 id="const" class="relative group">Const &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#const" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>Owner: More_surface Ted
Created time: July 25, 2024 4:59 PM&lt;/p></description></item><item><title>two First Post</title><link>https://code-agree.github.io/blog/two-first-post/</link><pubDate>Sat, 03 Aug 2024 00:13:28 +0800</pubDate><guid>https://code-agree.github.io/blog/two-first-post/</guid><description>&lt;p>This is my first blog post&lt;/p></description></item><item><title>My First Post</title><link>https://code-agree.github.io/blog/firstpost/</link><pubDate>Sat, 03 Aug 2024 00:11:28 +0800</pubDate><guid>https://code-agree.github.io/blog/firstpost/</guid><description>&lt;p>这是我的第一篇blog，希望能分享更多的技术，生活、兴趣在这个Blog上。欢迎大家查看评论。&lt;/p></description></item></channel></rss>