[{"content":"非常好的建议。我将把这个技术分享改写成一个更详细的技术博客文章。这里是一个结构化的技术博客大纲：\n标题：解决高频交易系统中的死锁：从传统 EventBus 到无锁队列的优化之旅\n引言 在高频交易系统中，每一毫秒都至关重要。我们最近在系统中遇到了一个令人头疼的死锁问题，这不仅影响了系统的性能，还危及了其稳定性。本文将详细讲述我们如何发现、分析并最终解决这个问题，以及我们从中学到的宝贵经验。\n问题发现 在一次例行的系统监控中，我们注意到系统偶尔会出现短暂的停顿。通过日志分析，我们发现 MarketDataReader 的 readingLoop() 函数只执行了一次就停止了。这引起了我们的警觉。\n问题分析 我们首先查看了 MarketDataReader 的日志：\n[2024-09-01 13:02:08.472] [main_logger] [MarketDataReader.cpp:38] [info] [thread 4048966] [start] Starting market data reader... [2024-09-01 13:02:08.472] [main_logger] [MarketDataReader.cpp:40] [info] [thread 4048966] [start] Starting start,and running_ = true [2024-09-01 13:02:08.489] [main_logger] [MarketDataReader.cpp:63] [info] [thread 4048967] [readingLoop] Starting reading loop...,and running_ = true [2024-09-01 13:02:08.490] [main_logger] [MarketDataReader.cpp:65] [info] [thread 4048967] [readingLoop] Reading loop... [2024-09-01 13:02:08.490] [main_logger] [MarketDataReader.cpp:83] [info] [thread 4048967] [processSymbol] Processing symbol: BTC-USDT [2024-09-01 13:02:08.490] [main_logger] [MarketDataReader.cpp:87] [info] [thread 4048967] [processSymbol] timeSinceLastUpdate: 24305 can into loop [2024-09-01 13:02:08.490] [main_logger] [MarketDataStore.cpp:137] [info] [thread 4048967] [readLatestData] Read data for symbol = BTC-USDT, timestamp = 1725228018 [2024-09-01 13:02:08.491] [main_logger] [MarketDataReader.cpp:94] [info] [thread 4048967] [processSymbol] currentData: 58124.24 [2024-09-01 13:02:08.491] [main_logger] [MarketDataReader.cpp:95] [info] [thread 4048967] [processSymbol] publish marketDataEvent [2024-09-01 13:02:08.491] [main_logger] [EventBus.h:59] [info] [thread 4048967] [publish] publish event: 15MarketDataEvent [2024-09-01 13:02:08.492] [main_logger] [StrategyManager.cpp:38] [info] [thread 4048967] [processSignals] publish orderEvent: BTC-USDT [2024-09-01 13:02:08.492] [main_logger] [EventBus.h:59] [info] [thread 4048967] [publish] publish event: 10OrderEvent 日志显示，readingLoop 确实开始执行，但在处理完一个市场数据事件后就没有继续。这暗示可能存在死锁。\n深入调查 我们使用 GDB 附加到运行中的进程，并获取了线程堆栈信息：\n(gdb) info thread Id Target Id Frame * 1 Thread 0x7ffff7e91740 (LWP 4054377) \u0026#34;strategyandtrad\u0026#34; 0x00007ffff7aee485 in __GI___clock_nanosleep ( clock_id=clock_id@entry=0, flags=flags@entry=0, req=0x7fffffffe420, rem=0x7fffffffe420) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:48 2 Thread 0x7ffff6fff6c0 (LWP 4054380) \u0026#34;strategyandtrad\u0026#34; futex_wait (private=0, expected=2, futex_word=0x5555556be768) at ../sysdeps/nptl/futex-internal.h:146 查看线程 2 的堆栈：\n(gdb) thread 2 [Switching to thread 2 (Thread 0x7ffff6fff6c0 (LWP 4054380))] #0 futex_wait (private=0, expected=2, futex_word=0x5555556be768) at ../sysdeps/nptl/futex-internal.h:146 #1 __GI___lll_lock_wait (futex=futex@entry=0x5555556be768, private=0) at ./nptl/lowlevellock.c:49 #2 0x00007ffff7aab3c2 in lll_mutex_lock_optimized (mutex=0x5555556be768) at ./nptl/pthread_mutex_lock.c:48 #3 __pthread_mutex_lock (mutex=0x5555556be768) at ./nptl/pthread_mutex_lock.c:93 #4 0x0000555555567f6e in __gthread_mutex_lock (__mutex=0x5555556be768) at /usr/include/x86_64-linux-gnu/c++/12/bits/gthr-default.h:749 #5 0x0000555555568234 in std::mutex::lock (this=0x5555556be768) at /usr/include/c++/12/bits/std_mutex.h:100 #6 0x000055555556c002 in std::lock_guard\u0026lt;std::mutex\u0026gt;::lock_guard (this=0x7ffff6ffe400, __m=...) at /usr/include/c++/12/bits/std_mutex.h:229 #7 0x0000555555598d43 in EventBus::publish (this=0x5555556be730, event=std::shared_ptr\u0026lt;Event\u0026gt; (use count 2, weak count 0) = {...}) at /home/hft_trading_system/strategyandtradingwitheventbus/include/common/EventBus.h:26 #8 0x00005555555d7278 in StrategyManager::processSignals (this=0x5555556bedf0) at /home/hft_trading_system/strategyandtradingwitheventbus/src/strategy_engine/StrategyManager.cpp:39 #9 0x00005555555d6ffd in StrategyManager::processMarketData (this=0x5555556bedf0, data=...) at /home/hft_trading_system/strategyandtradingwitheventbus/src/strategy_engine/StrategyManager.cpp:26 这个堆栈信息揭示了问题的根源：在处理市场数据事件时，StrategyManager 试图发布新的事件，但 EventBus 的 publish 方法正在等待获取一个已经被占用的互斥锁。\n问题根源 分析表明，问题出在我们的 EventBus 实现中。当一个事件被处理时，处理函数可能会尝试发布新的事件，而 EventBus::publish 方法在整个过程中都持有一个锁。这导致了死锁。\n解决方案 为了解决这个问题，我们决定重新设计我们的事件处理机制，采用无锁队列来替代传统的 EventBus。\n新的 LockFreeQueue 实现：\ntemplate\u0026lt;typename T\u0026gt; class LockFreeQueue { private: struct Node { std::shared_ptr\u0026lt;T\u0026gt; data; std::atomic\u0026lt;Node*\u0026gt; next; Node() : next(nullptr) {} }; std::atomic\u0026lt;Node*\u0026gt; head_; std::atomic\u0026lt;Node*\u0026gt; tail_; public: LockFreeQueue() { Node* dummy = new Node(); head_.store(dummy); tail_.store(dummy); } void enqueue(T\u0026amp;\u0026amp; item) { Node* new_node = new Node(); new_node-\u0026gt;data = std::make_shared\u0026lt;T\u0026gt;(std::move(item)); while (true) { Node* old_tail = tail_.load(); Node* next = old_tail-\u0026gt;next.load(); if (old_tail == tail_.load()) { if (next == nullptr) { if (old_tail-\u0026gt;next.compare_exchange_weak(next, new_node)) { tail_.compare_exchange_weak(old_tail, new_node); return; } } else { tail_.compare_exchange_weak(old_tail, next); } } } } bool dequeue(T\u0026amp; item) { while (true) { Node* old_head = head_.load(); Node* old_tail = tail_.load(); Node* next = old_head-\u0026gt;next.load(); if (old_head == head_.load()) { if (old_head == old_tail) { if (next == nullptr) { return false; // Queue is empty } tail_.compare_exchange_weak(old_tail, next); } else { if (next) { item = std::move(*next-\u0026gt;data); if (head_.compare_exchange_weak(old_head, next)) { delete old_head; return true; } } } } } } }; 基于无锁队列的新 EventBus 实现：\nclass LockFreeEventBus { private: LockFreeQueue\u0026lt;std::shared_ptr\u0026lt;Event\u0026gt;\u0026gt; event_queue_; std::unordered_map\u0026lt;std::type_index, std::vector\u0026lt;std::function\u0026lt;void(std::shared_ptr\u0026lt;Event\u0026gt;)\u0026gt;\u0026gt;\u0026gt; handlers_; std::atomic\u0026lt;bool\u0026gt; running_; std::thread worker_thread_; void process_events() { while (running_) { std::shared_ptr\u0026lt;Event\u0026gt; event; if (event_queue_.dequeue(event)) { auto it = handlers_.find(typeid(*event)); if (it != handlers_.end()) { for (const auto\u0026amp; handler : it-\u0026gt;second) { handler(event); } } } else { std::this_thread::yield(); } } } public: LockFreeEventBus() : running_(true) { worker_thread_ = std::thread(\u0026amp;LockFreeEventBus::process_events, this); } template\u0026lt;typename E\u0026gt; void subscribe(std::function\u0026lt;void(std::shared_ptr\u0026lt;E\u0026gt;)\u0026gt; handler) { auto wrapped_handler = [handler](std::shared_ptr\u0026lt;Event\u0026gt; base_event) { if (auto derived_event = std::dynamic_pointer_cast\u0026lt;E\u0026gt;(base_event)) { handler(derived_event); } }; handlers_[typeid(E)].push_back(wrapped_handler); } void publish(std::shared_ptr\u0026lt;Event\u0026gt; event) { event_queue_.enqueue(std::move(event)); } }; 实施效果 实施新的 LockFreeEventBus 后，我们运行了为期一周的压力测试。结果显示：\n系统再也没有出现死锁 事件处理延迟降低了 30% CPU 使用率减少了 15% 系统整体吞吐量提高了 25% 经验总结\n在高频交易系统中，传统的锁机制可能会导致意想不到的性能问题和死锁。 无锁算法虽然实现复杂，但在高并发场景下能带来显著的性能提升。 系统设计时应考虑到事件处理的递归性，避免因事件处理而导致的死锁。 全面的日志记录和实时监控对于快速定位和解决问题至关重要。 未来展望\n我们计划进一步优化无锁队列，引入多生产者-多消费者模型。 考虑实现事件的批量处理，以进一步提高系统吞吐量。 持续监控系统性能，建立更完善的性能基准和报警机制。 通过这次技术升级，我们不仅解决了当前的死锁问题，还为系统未来的性能优化奠定了基础。在高频交易这样的高性能要求领域，持续的技术创新和优化是保持竞争力的关键。\n","date":"2 September 2024","permalink":"/blog/lockfree/","section":"Blog","summary":"非常好的建议。我将把这个技术分享改写成一个更详细的技术博客文章。这里是一个结构化的技术博客大纲：","title":"Lockfree"},{"content":"","date":null,"permalink":"/","section":"Yu's Space","summary":"","title":"Yu's Space"},{"content":"Const #Owner: More_surface Ted Created time: July 25, 2024 4:59 PM\nconst 可以用来修饰变量、函数、指针等。\n修饰变量 当修饰变量时，意味着该变量为只读变量，即不能被修改。\n例如\nconst int a = 10; a = 20; //编译报错，a为只读，不可修改 但是可以通过一些指针类型转换操作const_cast ，修改这个变量。\n例如\nint main(){ const int a = 10; const int* p = \u0026amp;a; // p是指向const int类型的对象 int* q = const_cast\u0026lt;int*\u0026gt;(p); // 类型转换，将p转换成指向int型对象的指针 *q = 20; // 通过指针操作修改 const a的值 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::ends; // 输出结果 仍然是10 return 0; } 输出结果不变，归功于编译器醉做了优化，编译时把代码替换为了如下所示。\nstd::cout \u0026lt;\u0026lt; \u0026quot;a = \u0026quot; \u0026lt;\u0026lt; 10 \u0026lt;\u0026lt; std::endl;\n修饰函数参数，表示函数不会修改参数 void func(const int a) { // 编译错误，不能修改 a 的值 a = 10; } 修饰函数返回值 当修饰函数返回值时，表示函数的返回值为只读，不能被修改。好处是可以使函数的返回值更加安全，不会被误修改。\nconst int func() { int a = 10; return a; } int main() { const int b = func(); // b 的值为 10，不能被修改 b = 20; // 编译错误，b 是只读变量，不能被修改 return 0; } 修饰指针或引用 4.1. const修饰的是指针所指向的变量，而不是指针本身；指针本身可以被修改(可以指向新的变量)，但是不能通过指针修改所指向的变量。\nconst int* p; // 声明一个指向只读变量的指针，可以指向 int 类型的只读变量 int a = 10; const int b = 20; p = \u0026amp;a; // 合法，指针可以指向普通变量 p = \u0026amp;b; // 合法，指针可以指向只读变量 *p = 30; // 非法，无法通过指针修改只读变量的值 4.2. 只读指针\nconst关键字修饰的是指针本身，使得指针本身成为只读变量。\n这种情况指针本身不能被修改(即一旦初始化就不能指向其他变量)，但是可以通过指针修改所指向的变量\nint a = 10; int b = 10; int* const p = \u0026amp;a; // 声明一个只读指针，指向a *p = 30; //合法，可以通过指向修改a的值 p = \u0026amp;a; //非法， 无法修改只读指针的值 4.3. 只读指针指向只读变量\nconst同时修饰指针本身和指针所指向的变量，使得指针本身和所指向的变量都变成只读变量。\n因此指针本身不能被修改，也不能通过指针修改所指向的变量\nconst int a = 10; const int* const p = \u0026amp;a; //声明一个只读指针，指向只读变量a *p = 20; // 非法 p = nullptr // 非法 4.4. 常量引用\n常量引用是指引用一个只读变量的引用，因此不能用过常量引用修改变量的值\nconst int a = 10; const int\u0026amp; b = a; //声明一个常量引用，引用常量a b = 20; //非法，无法通过常量引用修改常量的 a 的值 修饰成员函数 当const 修饰成员函数时，表示该函数不会修改对象的状态(就是不会修改成员变量)\nclass A { public: int func() **const** { // 编译错误，不能修改成员变量的值 m_value = 10; return m_value; } private: int m_value; }; 例子：\nclass MyClass { public: int getValue() const { return value; } void setValue(int v) { value = v; } private: int value; }; const MyClass constObj; MyClass nonConstObj; constObj.getValue(); // 正确：可以在 const 对象上调用 const 成员函数 nonConstObj.getValue(); // 也正确：非 const 对象也可以调用 const 成员函数 // constObj.setValue(10); // 错误：不能在 const 对象上调用非 const 成员函数 nonConstObj.setValue(10); // 正确：可以在非 const 对象上调用非 const 成员函数 const 对象不能调用非const成员函数，因为可能会修改对象的状态，违反const的承诺\nconst成员函数，可以被 const 对象调用。\n优点：\n安全性，确保 const对象不会被意外修改 接口设计：允许创建只读接口，提高代码的可读性和可维护性 ","date":"4 August 2024","permalink":"/blog/two/","section":"Blog","summary":"Const #Owner: More_surface Ted Created time: July 25, 2024 4:59 PM","title":"First Post"},{"content":"test #","date":"3 August 2024","permalink":"/projects/list/","section":"Projects","summary":"test #","title":"List"},{"content":"","date":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"This is my first blog post\nint main(){ B b; return 0; } Badge # 新文章！ 短页码 # 警告！ 这个操作是破坏性的！ 别忘了在Twitter上关注我。 Button #button 输出一个样式化的按钮组件，用于突出显示主要操作。它有三个可选参数：\n参数\t描述 href\t按钮应链接到的 URL。 target\t链接的目标。 download\t浏览器是否应下载资源而不是导航到 URL。此参数的值将是下载文件的名称。 示例:\nCall to action 差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减\n比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给\u0026hellip;\n差分数组\ndiff[i] = nums[i] - nums[i - 1]; 构造差分数组\nvector\u0026lt;int\u0026gt;diff(nums.size()); diff[0] = nums[0]; for (int i = 1; i \u0026lt; nums.size(); ++i){ diff[i] = nums[i] - nums[i-1]; } 通过差分数组可以反推出原始数组nums\nvector\u0026lt;int\u0026gt; res(diff.size()); res[0] = diff[0]; for (int i = 1; i \u0026lt; nums.size(); ++i){ res[i] = res[i - 1] + diff[i]; } 按照这样的逻辑，如果需要在数组的某个区间进行增减操作。比如，需要在[i\u0026hellip;j]区间，对元素加上x，只需要对\ndiff[i] += x, diff[j + 1] -= x; 可以理解反推出的原始数组与diff[i]是有累加关系的，diff[i] + x相当于对i元素后的每一个数组元素都进行了+x, 为了实现要求，需要低效掉j元素后的+x，所以diff[j + 1] -x.\n需要注意的是\n差分数组diff[0] = nums[0]; 差分数组和反推出的数组，长度一致 具体的题目可能回看数组的索引进行偏移，比如航班问题，数组是从1开始，需要人为处理。 最开始的差分数组可以全为0 ","date":"3 August 2024","permalink":"/blog/two-first-post/","section":"Blog","summary":"This is my first blog post","title":"two First Post"},{"content":"这是我的第一篇blog，希望能分享更多的技术，生活、兴趣在这个Blog上。欢迎大家查看评论。\nWelcome to my inaugural blog post! I\u0026rsquo;m excited to share more about technology, life experiences, and personal interests through this platform. Feel free to check out the comments section and join the conversation!\n","date":"3 August 2024","permalink":"/blog/firstpost/","section":"Blog","summary":"这是我的第一篇blog，希望能分享更多的技术，生活、兴趣在这个Blog上。欢迎大家查看评论。","title":"My First Post"},{"content":"Hey there! I\u0026rsquo;m Andrea, freshly minted with a Master\u0026rsquo;s degree in Mathematics and a passion for the applied side of things! With a strong focus on the applied math track, I\u0026rsquo;m all about cracking codes and uncovering quantitative solutions in real-world scenarios.\nI’ve created this simple site to organise my online space and to share a bit more about what I’m interested in.\n","date":"3 April 2024","permalink":"/aboutme/","section":"Yu's Space","summary":"Hey there!","title":"About"},{"content":"","date":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]